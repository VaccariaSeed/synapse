package protocol

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"fmt"
)

var crcHighBytes = []byte{
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
}

var crcLowBytes = []byte{
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04,
	0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8,
	0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
	0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10,
	0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
	0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
	0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C,
	0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0,
	0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
	0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
	0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C,
	0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
	0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
	0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
	0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40,
}

var modbusRTUFuncCodeArray = []byte{ReadCoilsCode, ReadDiscreteInputsCode, ReadHoldingInputsCode, ReadInputInputsCode, WriteSingleCoilCode, WriteSingleRegisterCode, WriteMultipleCoilsCode, WriteMultipleRegistersCode}

const (
	crcSeat                    byte = 0xFF
	ModbusRTUPacketName             = "modbus_rtu"
	ReadCoilsCode              byte = 0x01 //功能码 读线圈（Read Coils)
	ReadDiscreteInputsCode     byte = 0x02 //功能码 读离散输入寄存器（Read Discrete Inputs)
	ReadHoldingInputsCode      byte = 0x03
	ReadInputInputsCode        byte = 0x04
	WriteSingleCoilCode        byte = 0x05
	WriteSingleRegisterCode    byte = 0x06
	WriteMultipleCoilsCode     byte = 0x0F
	WriteMultipleRegistersCode byte = 0x10
	rtuDataMaxSize                  = 252
)

func NewModbusRTUPacket(address uint8) *ModbusRTUPacket {
	return &ModbusRTUPacket{address: address}
}

// ModbusRTUPacket modbusRTU的报文结构
type ModbusRTUPacket struct {
	address  byte   //地址
	funcCode byte   //功能码
	data     []byte //数据
	crc      uint16 //校验码
}

func (m *ModbusRTUPacket) Decode(msg []byte) (funcCode byte, result []byte, err error) {
	reader := bufio.NewReader(bytes.NewBuffer(msg))
	return m.DecodeByReader(reader)
}

// todo 没写完
func (m *ModbusRTUPacket) DecodeByReader(reader *bufio.Reader) (funcCode byte, result []byte, err error) {
	for {
		var slaveId byte
		err = binary.Read(reader, binary.LittleEndian, &slaveId)
		if err != nil {
			return 0, nil, err
		}
		if slaveId != m.address {
			return 0, nil, fmt.Errorf("error slaveId:%d", slaveId)
		}
		//读取功能码
		err = binary.Read(reader, binary.LittleEndian, &funcCode)
		if err != nil {
			return 0, nil, err
		}
		if bytes.IndexByte(modbusRTUFuncCodeArray, funcCode) == -1 {
			return 0, nil, fmt.Errorf("error function code:%d", funcCode)
		}
		csArray := []byte{m.address, funcCode}
		var data []byte
		switch funcCode {
		case ReadCoilsCode, ReadDiscreteInputsCode, ReadHoldingInputsCode, ReadInputInputsCode:
			var dataSize byte
			err = binary.Read(reader, binary.LittleEndian, &dataSize)
			if err != nil {
				return 0, nil, err
			}
			data = make([]byte, dataSize)
			err = binary.Read(reader, binary.LittleEndian, &data)
			if err != nil {
				return 0, nil, err
			}
			csArray = append(csArray, dataSize)

		case WriteSingleCoilCode, WriteSingleRegisterCode:
			data = make([]byte, 4)
			err = binary.Read(reader, binary.LittleEndian, &data)
			if err != nil {
				return 0, nil, err
			}
		case WriteMultipleCoilsCode, WriteMultipleRegistersCode:

		}

		csArray = append(csArray, data...)

	}
}

// CreateReadCoils 读线圈 取得一组逻辑线圈的当前状态(ON/OFF)
// startAddress 寄存器起始地址
// addressSize 寄存器数量
func (p *ModbusRTUPacket) CreateReadCoils(startAddress uint16, addressSize uint16) ([]byte, error) {
	return p.CreateReadFrame(ReadCoilsCode, startAddress, addressSize)
}

// CreateReadDiscreteInputs 读离散输入寄存器 取得一组开关输入的当前状态(ON/OFF)
// startAddress 寄存器起始地址
// addressSize 寄存器数量
func (p *ModbusRTUPacket) CreateReadDiscreteInputs(startAddress uint16, addressSize uint16) ([]byte, error) {
	return p.CreateReadFrame(ReadDiscreteInputsCode, startAddress, addressSize)
}

// CreateReadHoldingInputs 读保持寄存器（Read Holding Registers)在一个或多个保持寄存器中取得当前的二进制值
// startAddress 寄存器起始地址
// addressSize 寄存器数量
func (p *ModbusRTUPacket) CreateReadHoldingInputs(startAddress uint16, addressSize uint16) ([]byte, error) {
	return p.CreateReadFrame(ReadHoldingInputsCode, startAddress, addressSize)
}

// CreateReadInputInputs 读输入寄存器（Read Input Inputs) 在一个或多个输入寄存器中取得当前的二进制值
// startAddress 寄存器起始地址
// addressSize 寄存器数量
func (p *ModbusRTUPacket) CreateReadInputInputs(startAddress uint16, addressSize uint16) ([]byte, error) {
	return p.CreateReadFrame(ReadInputInputsCode, startAddress, addressSize)
}

// CreateWriteSingleCoil 写单个线圈寄存器 （Write Single Coil) 强置一个逻辑线圈的通断状态
// startAddress 寄存器起始地址
// addressSize 写入数据
func (p *ModbusRTUPacket) CreateWriteSingleCoil(startAddress uint16, data uint16) ([]byte, error) {
	return p.CreateReadFrame(WriteSingleCoilCode, startAddress, data)
}

// CreateWriteSingleRegister 写单个保持寄存器（Write Single Register)把具体二进制值装入一个保持寄存器
// startAddress 寄存器起始地址
// addressSize 写入数据
func (p *ModbusRTUPacket) CreateWriteSingleRegister(startAddress uint16, data uint16) ([]byte, error) {
	return p.CreateReadFrame(WriteSingleRegisterCode, startAddress, data)
}

// CreateWriteMultipleCoils 写多个线圈寄存器（Write Multiple Coils) 强置一串连续逻辑线圈的通断
// startAddress 寄存器起始地址
// coilSize 元器件数
// addressSize 写入数据
func (p *ModbusRTUPacket) CreateWriteMultipleCoils(startAddress uint16, coilSize uint16, data []byte) ([]byte, error) {
	if data == nil || len(data) >= rtuDataMaxSize-1 {
		return nil, fmt.Errorf("invalid data")
	}
	p.funcCode = byte(WriteMultipleCoilsCode)
	sa := Uint16(startAddress)
	p.data = append(p.data, sa.ToBytesBE()...)
	as := Uint16(coilSize)
	p.data = append(p.data, as.ToBytesBE()...)
	p.data = append(p.data, byte(len(data)))
	p.data = append(p.data, data...)
	return p.Encode()
}

// CreateWriteMultipleRegisters 写多个保持寄存器（Write Multiple Registers)
// startAddress 寄存器起始地址
// coilSize 元器件数
// addressSize 写入数据
func (p *ModbusRTUPacket) CreateWriteMultipleRegisters(startAddress uint16, coilSize uint16, data []byte) ([]byte, error) {
	if data == nil || len(data) >= rtuDataMaxSize-1 {
		return nil, fmt.Errorf("invalid data")
	}
	p.funcCode = byte(WriteMultipleRegistersCode)
	sa := Uint16(startAddress)
	p.data = append(p.data, sa.ToBytesBE()...)
	as := Uint16(coilSize)
	p.data = append(p.data, as.ToBytesBE()...)
	p.data = append(p.data, byte(len(data)))
	p.data = append(p.data, data...)
	return p.Encode()
}

// CreateReadFrame 创建读报文
// funcCode 功能码
// startAddress 寄存器起始地址
// addressSize 寄存器数量
func (p *ModbusRTUPacket) CreateReadFrame(funcCode byte, startAddress uint16, addressSize uint16) ([]byte, error) {
	if addressSize < 1 || addressSize > 125 {
		return nil, fmt.Errorf("address size must be between 1 and 125")
	}
	p.funcCode = byte(funcCode)
	sa := Uint16(startAddress)
	p.data = append(p.data, sa.ToBytesBE()...)
	as := Uint16(addressSize)
	p.data = append(p.data, as.ToBytesBE()...)
	return p.Encode()
}

func (m *ModbusRTUPacket) Encode() ([]byte, error) {
	if len(m.data) > rtuDataMaxSize {
		return nil, fmt.Errorf("modbus rtu data too large, must be < %d bytes", rtuDataMaxSize)
	}
	frame := []byte{m.address, m.funcCode}
	frame = append(frame, m.data...)
	//计算crc
	return append(frame, m.Cs(frame)...), nil
}

func (m *ModbusRTUPacket) EncodeToString() (string, error) {
	frame, err := m.Encode()
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(frame), nil
}

func (m *ModbusRTUPacket) Name() string {
	return ModbusRTUPacketName
}

func (p *ModbusRTUPacket) Cs(data []byte) []byte {
	var idx, b byte
	low := crcSeat
	high := crcSeat
	for _, b = range data {
		idx = low ^ b
		low = high ^ crcHighBytes[idx]
		high = crcLowBytes[idx]
	}
	return []byte{low, high}
}
